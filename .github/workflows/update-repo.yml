name: Update APT Repository

on:
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-repo:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Install dependencies
      run: |
        sudo apt-get update && sudo apt-get install -y reprepro gnupg2 debsigs jq dpkg-dev
        
    - name: Setup GPG
      env:
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
      run: |
        echo "$GPG_PRIVATE_KEY" | gpg --import --batch
        
        cat >> ~/.gnupg/gpg.conf << EOF
        use-agent
        pinentry-mode loopback
        batch
        yes
        EOF
        
        cat >> ~/.gnupg/gpg-agent.conf << EOF
        allow-loopback-pinentry
        max-cache-ttl 7200
        default-cache-ttl 7200
        EOF
        
        gpg-connect-agent reloadagent /bye
        
        echo "test" | gpg --batch --yes --passphrase "$GPG_PASSPHRASE" \
          --pinentry-mode loopback --default-key "$GPG_KEY_ID" \
          --clearsign > /dev/null
        
        echo "$GPG_PASSPHRASE" | /usr/lib/gnupg2/gpg-preset-passphrase \
          --preset $(gpg --with-keygrip --list-secret-keys "$GPG_KEY_ID" | grep Keygrip | head -1 | awk '{print $3}') || true
        
    - name: Verify reprepro configuration
      run: |
        if [ ! -f conf/distributions ]; then
          echo "Error: conf/distributions not found"
          exit 1
        fi
        echo "Using existing conf/distributions:"
        cat conf/distributions
        
    - name: Download packages from ALL releases
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        mkdir -p incoming
        
        echo "ðŸ“¦ Fetching all releases..."
        
        # Fetch all releases
        curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100" \
          > releases.json
        
        # Check if request was successful
        if ! jq -e '. | length > 0' releases.json > /dev/null 2>&1; then
          echo "âŒ Failed to fetch releases or no releases found"
          cat releases.json
          exit 1
        fi
        
        RELEASE_COUNT=$(jq '. | length' releases.json)
        echo "âœ… Found $RELEASE_COUNT releases"
        
        # Download all .deb files from all releases
        jq -r '.[] | select(.assets != null) | .tag_name as $tag | .assets[] | select(.name | endswith(".deb")) | "\(.browser_download_url)|\($tag)|\(.name)"' releases.json \
          | while IFS='|' read -r url tag name; do
              if [ -n "$url" ]; then
                echo "Downloading $name from $tag..."
                wget -q --show-progress -P incoming/ "$url" || echo "âš ï¸ Failed to download $url"
              fi
            done
        
        DEB_COUNT=$(find incoming -name "*.deb" 2>/dev/null | wc -l)
        echo "âœ… Downloaded $DEB_COUNT .deb file(s) from all releases"
        ls -lh incoming/ || true
        
    - name: Extract package metadata and build filename mapping
      run: |
        echo "ðŸ“‹ Extracting package control information..."
        
        mkdir -p /tmp/package-info
        
        # Extract package name, version, and architecture from each .deb
        for deb in incoming/*.deb; do
          if [ -f "$deb" ]; then
            ORIGINAL_FILENAME=$(basename "$deb")
            
            # Extract control information
            PKG_NAME=$(dpkg-deb -f "$deb" Package)
            PKG_VERSION=$(dpkg-deb -f "$deb" Version)
            PKG_ARCH=$(dpkg-deb -f "$deb" Architecture)
            
            # Debian pool filename format: package_version_arch.deb
            POOL_FILENAME="${PKG_NAME}_${PKG_VERSION}_${PKG_ARCH}.deb"
            
            # Determine pool path: pool/component/first-letter/package-name/
            FIRST_LETTER=$(echo "$PKG_NAME" | cut -c1)
            if [[ "$PKG_NAME" == lib* ]]; then
              # For packages starting with 'lib', use first 4 characters
              FIRST_LETTER=$(echo "$PKG_NAME" | cut -c1-4)
            fi
            
            # Assume 'main' component (adjust based on your conf/distributions)
            POOL_PATH="pool/main/${FIRST_LETTER}/${PKG_NAME}/${POOL_FILENAME}"
            
            echo "$ORIGINAL_FILENAME|$POOL_FILENAME|$POOL_PATH|$PKG_NAME|$PKG_VERSION|$PKG_ARCH" >> /tmp/package-info/mapping.txt
            
            echo "  $ORIGINAL_FILENAME -> $POOL_FILENAME"
          fi
        done
        
        echo "âœ… Package metadata extracted"
        cat /tmp/package-info/mapping.txt
        
    - name: Export public key
      env:
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
      run: |
        mkdir -p public/dists
        gpg --armor --export "$GPG_KEY_ID" > public/dists/public-key.asc
        cp public/dists/public-key.asc public/KEY.gpg
        
        if gpg --dry-run --import public/dists/public-key.asc 2>/dev/null; then
          echo "âœ… Public key exported successfully"
          gpg --show-keys public/dists/public-key.asc
        else
          echo "âŒ Failed to export public key"
          exit 1
        fi
        
    - name: Update repository
      env:
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
      run: |
        DISTRIBUTION="alpha"
        
        echo "ðŸ“¦ Adding packages to repository..."
        for deb in incoming/*.deb; do
          if [ -f "$deb" ]; then
            echo "Adding: $(basename $deb)"
            reprepro -b . -V includedeb $DISTRIBUTION "$deb" || echo "âš ï¸ Failed to add $(basename $deb)"
          fi
        done
        
        echo "ðŸ” Exporting and signing repository..."
        reprepro -b . export $DISTRIBUTION
        
        echo "ðŸ“‹ Repository contents:"
        reprepro -b . list $DISTRIBUTION || true
        
        # Copy repository metadata to public
        cp -r dists public/
        
    - name: Generate release map JSON
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "ðŸ“‹ Generating release map with actual pool paths..."
        
        mkdir -p public
        
        # Start JSON structure
        cat > public/release-map.json << 'JSONEOF'
{
  "_metadata": {
    "generated_at": "
JSONEOF
        date -u +"%Y-%m-%dT%H:%M:%SZ" >> public/release-map.json
        cat >> public/release-map.json << JSONEOF
",
    "repository": "${{ github.repository }}",
    "total_releases": $(jq '. | length' releases.json),
    "note": "Pool filenames follow Debian convention: package_version_arch.deb"
  },
JSONEOF
        
        # Build the mapping using the extracted package info
        echo "  \"packages\": {" >> public/release-map.json
        
        FIRST_ENTRY=true
        while IFS='|' read -r original_filename pool_filename pool_path pkg_name pkg_version pkg_arch; do
          # Find which release this package came from
          RELEASE_TAG=$(jq -r --arg name "$original_filename" \
            '.[] | select(.assets != null) | select(.assets[] | .name == $name) | .tag_name' \
            releases.json | head -1)
          
          DOWNLOAD_URL=$(jq -r --arg name "$original_filename" \
            '.[] | select(.assets != null) | .assets[] | select(.name == $name) | .browser_download_url' \
            releases.json | head -1)
          
          ASSET_SIZE=$(jq -r --arg name "$original_filename" \
            '.[] | select(.assets != null) | .assets[] | select(.name == $name) | .size' \
            releases.json | head -1)
          
          if [ "$FIRST_ENTRY" = false ]; then
            echo "," >> public/release-map.json
          fi
          FIRST_ENTRY=false
          
          # Use pool_filename as key (what APT will request)
          cat >> public/release-map.json << ENTRYEOF
    "$pool_filename": {
      "release": "$RELEASE_TAG",
      "originalAssetName": "$original_filename",
      "poolPath": "$pool_path",
      "packageName": "$pkg_name",
      "version": "$pkg_version",
      "architecture": "$pkg_arch",
      "downloadUrl": "$DOWNLOAD_URL",
      "size": $ASSET_SIZE
    }
ENTRYEOF
        done < /tmp/package-info/mapping.txt
        
        echo "" >> public/release-map.json
        echo "  }" >> public/release-map.json
        echo "}" >> public/release-map.json
        
        echo "âœ… Release map generated: public/release-map.json"
        
        # Count packages
        PACKAGE_COUNT=$(jq '.packages | keys | length' public/release-map.json)
        echo "ðŸ“¦ Total packages mapped: $PACKAGE_COUNT"
        
        # Display preview
        echo "ðŸ“„ Release map preview:"
        jq '._metadata' public/release-map.json
        echo ""
        jq '.packages | to_entries | .[0:2] | from_entries' public/release-map.json
        
    - name: Create additional metadata
      run: |
        echo "ðŸ“‹ Creating additional metadata files..."
        
        # Create releases.json with detailed information
        jq '[.[] | select(.assets != null) | {
          tag: .tag_name,
          name: .name,
          published_at: .published_at,
          prerelease: .prerelease,
          draft: .draft,
          packages: [.assets[] | select(.name | endswith(".deb")) | {
            name: .name,
            size: .size,
            download_count: .download_count,
            created_at: .created_at,
            browser_download_url: .browser_download_url
          }]
        }]' releases.json > public/releases.json
        
        # Create index.html for the repository
        cat > public/index.html << 'HTMLEOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noraneko APT Repository</title>
    <style>
        body { font-family: system-ui; max-width: 800px; margin: 40px auto; padding: 0 20px; }
        pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
        code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
        h1 { color: #333; }
        .section { margin: 30px 0; }
    </style>
</head>
<body>
    <h1>Noraneko APT Repository</h1>
    <div class="section">
        <h2>Setup Instructions</h2>
        <p>Add this repository to your system:</p>
        <pre><code>curl -fsSL https://apt.yourdomain.com/KEY.gpg | sudo gpg --dearmor -o /usr/share/keyrings/noraneko.gpg
echo "deb [signed-by=/usr/share/keyrings/noraneko.gpg] https://apt.yourdomain.com alpha main" | sudo tee /etc/apt/sources.list.d/noraneko.list
sudo apt update</code></pre>
    </div>
    <div class="section">
        <h2>Available Resources</h2>
        <ul>
            <li><a href="/release-map.json">Release Map</a> - Package to release mapping (includes pool paths)</li>
            <li><a href="/releases.json">Releases</a> - Detailed release information</li>
            <li><a href="/KEY.gpg">GPG Key</a> - Repository signing key</li>
        </ul>
    </div>
    <div class="section">
        <h2>How it works</h2>
        <p>This repository uses Cloudflare Workers to proxy .deb files from GitHub releases. 
        When APT requests a package from the pool (e.g., <code>pool/main/n/noraneko-alpha/noraneko-alpha_0.2.0~build1_amd64.deb</code>),
        the worker maps it to the original GitHub release asset and serves it directly.</p>
    </div>
</body>
</html>
HTMLEOF
        
        echo "âœ… Metadata files created"
        ls -lh public/
        
    - name: Deploy to Cloudflare Workers
      uses: cloudflare/wrangler-action@v3
      with:
        apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        
    - name: Commit changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "github-actions"
        git add public/ dists/ db/ pool/ 2>/dev/null || true
        git commit -m "Update APT repository [skip ci]" || echo "No changes to commit"
        git push || echo "Nothing to push"
