name: Update APT Repository

on:
  release:
    types: [published]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-repo:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Install dependencies
      run: |
        sudo apt-get update && sudo apt-get install -y reprepro gnupg2 debsigs jq dpkg-dev
        
    - name: Setup GPG
      env:
        GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
      run: |
        echo "$GPG_PRIVATE_KEY" | gpg --import --batch
        
        cat >> ~/.gnupg/gpg.conf << EOF
        use-agent
        pinentry-mode loopback
        batch
        yes
        EOF
        
        cat >> ~/.gnupg/gpg-agent.conf << EOF
        allow-loopback-pinentry
        max-cache-ttl 7200
        default-cache-ttl 7200
        EOF
        
        gpg-connect-agent reloadagent /bye
        
        echo "test" | gpg --batch --yes --passphrase "$GPG_PASSPHRASE" \
          --pinentry-mode loopback --default-key "$GPG_KEY_ID" \
          --clearsign > /dev/null
        
        echo "$GPG_PASSPHRASE" | /usr/lib/gnupg2/gpg-preset-passphrase \
          --preset $(gpg --with-keygrip --list-secret-keys "$GPG_KEY_ID" | grep Keygrip | head -1 | awk '{print $3}') || true
        
    - name: Verify reprepro configuration
      run: |
        if [ ! -f conf/distributions ]; then
          echo "Error: conf/distributions not found"
          exit 1
        fi
        echo "Using existing conf/distributions:"
        cat conf/distributions
        
    - name: Download packages from ALL releases
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        mkdir -p incoming
        
        echo "ðŸ“¦ Fetching all releases..."
        
        # Fetch all releases
        curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github+json" \
          "https://api.github.com/repos/${{ github.repository }}/releases?per_page=100" \
          > releases.json
        
        # Check if request was successful
        if ! jq -e '. | length > 0' releases.json > /dev/null 2>&1; then
          echo "âŒ Failed to fetch releases or no releases found"
          cat releases.json
          exit 1
        fi
        
        RELEASE_COUNT=$(jq '. | length' releases.json)
        echo "âœ… Found $RELEASE_COUNT releases"
        
        # Download all .deb files from all releases
        jq -r '.[] | select(.assets != null) | .tag_name as $tag | .assets[] | select(.name | endswith(".deb")) | "\(.browser_download_url)|\($tag)|\(.name)"' releases.json \
          | while IFS='|' read -r url tag name; do
              if [ -n "$url" ]; then
                echo "Downloading $name from $tag..."
                wget -q --show-progress -P incoming/ "$url" || echo "âš ï¸ Failed to download $url"
              fi
            done
        
        DEB_COUNT=$(find incoming -name "*.deb" 2>/dev/null | wc -l)
        echo "âœ… Downloaded $DEB_COUNT .deb file(s) from all releases"
        ls -lh incoming/ || true
        
    - name: Extract package metadata and build filename mapping
      run: |
        echo "ðŸ“‹ Extracting package control information..."
        
        mkdir -p /tmp/package-info
        
        # Extract package name, version, and architecture from each .deb
        for deb in incoming/*.deb; do
          if [ -f "$deb" ]; then
            ORIGINAL_FILENAME=$(basename "$deb")
            
            # Extract control information
            PKG_NAME=$(dpkg-deb -f "$deb" Package)
            PKG_VERSION=$(dpkg-deb -f "$deb" Version)
            PKG_ARCH=$(dpkg-deb -f "$deb" Architecture)
            
            # Debian pool filename format: package_version_arch.deb
            POOL_FILENAME="${PKG_NAME}_${PKG_VERSION}_${PKG_ARCH}.deb"
            
            # Determine pool path: pool/component/first-letter/package-name/
            FIRST_LETTER=$(echo "$PKG_NAME" | cut -c1)
            if [[ "$PKG_NAME" == lib* ]]; then
              # For packages starting with 'lib', use first 4 characters
              FIRST_LETTER=$(echo "$PKG_NAME" | cut -c1-4)
            fi
            
            # Assume 'main' component (adjust based on your conf/distributions)
            POOL_PATH="pool/main/${FIRST_LETTER}/${PKG_NAME}/${POOL_FILENAME}"
            
            echo "$ORIGINAL_FILENAME|$POOL_FILENAME|$POOL_PATH|$PKG_NAME|$PKG_VERSION|$PKG_ARCH" >> /tmp/package-info/mapping.txt
            
            echo "  $ORIGINAL_FILENAME -> $POOL_FILENAME"
          fi
        done
        
        echo "âœ… Package metadata extracted"
        cat /tmp/package-info/mapping.txt
        
    - name: Export public key
      env:
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
      run: |
        mkdir -p public/dists
        gpg --armor --export "$GPG_KEY_ID" > public/dists/public-key.asc
        cp public/dists/public-key.asc public/KEY.gpg
        
        if gpg --dry-run --import public/dists/public-key.asc 2>/dev/null; then
          echo "âœ… Public key exported successfully"
          gpg --show-keys public/dists/public-key.asc
        else
          echo "âŒ Failed to export public key"
          exit 1
        fi
        
    - name: Update repository
      env:
        GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}
      run: |
        DISTRIBUTION="alpha"
        
        echo "ðŸ“¦ Adding packages to repository..."
        for deb in incoming/*.deb; do
          if [ -f "$deb" ]; then
            echo "Adding: $(basename $deb)"
            reprepro -b . -V includedeb $DISTRIBUTION "$deb" || echo "âš ï¸ Failed to add $(basename $deb)"
          fi
        done
        
        echo "ðŸ” Exporting and signing repository..."
        reprepro -b . export $DISTRIBUTION
        
        echo "ðŸ“‹ Repository contents:"
        reprepro -b . list $DISTRIBUTION || true
        
        # Copy repository metadata to public
        cp -r dists public/
        
    - name: Generate release map JSON
      run: |
        # Fail on any error (-e), undefined variable (-u), or error in a pipeline (-o pipefail).
        set -euo pipefail
        
        # --- Configuration ---
        # Use environment variables from GitHub Actions, with local fallbacks.
        RELEASES_FILE="${1:-releases.json}"
        MAPPING_FILE="${2:-/tmp/package-info/mapping.txt}"
        OUTPUT_DIR="public"
        OUTPUT_FILE="$OUTPUT_DIR/release-map.json"
        # The GITHUB_REPOSITORY is provided by the GitHub Actions runner environment.
        GITHUB_REPOSITORY="${GITHUB_REPOSITORY:-your/repository}" 
        
        # --- Pre-flight Checks ---
        echo "ðŸ”Ž Running pre-flight checks..."
        # Ensure jq is available
        if ! command -v jq &> /dev/null; then
            echo "âŒ Error: jq is not installed. Please install it to continue." >&2
            exit 1
        fi
        # Ensure input files exist to prevent cryptic errors later
        for f in "$RELEASES_FILE" "$MAPPING_FILE"; do
            if [[ ! -f "$f" ]]; then
                echo "âŒ Error: Input file not found at '$f'" >&2
                exit 1
            fi
        done
        echo "âœ… Checks passed."
        
        
        # --- Main Logic ---
        echo "ðŸ“‹ Generating release map..."
        mkdir -p "$OUTPUT_DIR"
        
        # This jq program is defined in a variable for clarity.
        # It's more robust, safely handling packages from the mapping file that
        # might not have a corresponding entry in the releases.json data.
        read -r -d '' JQ_PROGRAM << 'EOF'
        (
          [
            inputs | . as $pkg_map |
            # Look up release data; defaults to null if not found.
            ($release_info_map[$pkg_map.originalAssetName] // null) as $release_data |
            # Only process entries that have a corresponding release asset. This prevents
            # errors from trying to access fields on a null value, a likely cause of the original error.
            if $release_data != null then
              {
                key: $pkg_map.pool_filename,
                value: {
                  release: $release_data.release,
                  originalAssetName: $pkg_map.originalAssetName,
                  poolPath: $pkg_map.poolPath,
                  packageName: $pkg_map.packageName,
                  version: $pkg_map.version,
                  architecture: $pkg_map.architecture,
                  downloadUrl: $release_data.downloadUrl,
                  size: $release_data.size
                }
              }
            # Silently skip mapping entries that don't have a corresponding release asset.
            else empty end
          ] | from_entries
        ) as $packages |
        # Construct the final JSON object with metadata.
        {
          _metadata: {
            generated_at: $generated_at,
            repository: $repo,
            total_releases: $total_releases,
            note: "Pool filenames follow Debian convention: package_version_arch.deb"
          },
          packages: $packages
        }
        EOF
        
        # This single, powerful jq command generates the entire release map.
        # 1. `--slurpfile` reads the entire releases.json into a variable, after transforming it into an efficient lookup map.
        # 2. `--arg`/`--argjson` pass shell variables into the jq program.
        # 3. The final argument uses process substitution to stream the mapping.txt file, pre-converted to JSON objects, into the program.
        jq \
          --slurpfile release_info_map <(jq '[ .[] | .assets[]? | {key: .name, value: {release: .tag_name, downloadUrl: .browser_download_url, size: .size}} ] | from_entries' "$RELEASES_FILE") \
          --arg repo "$GITHUB_REPOSITORY" \
          --arg generated_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
          --argjson total_releases "$(jq '. | length' "$RELEASES_FILE")" \
          "$JQ_PROGRAM" \
          <(jq -cR 'split("|") | {originalAssetName: .[0], pool_filename: .[1], poolPath: .[2], packageName: .[3], version: .[4], architecture: .[5]}' "$MAPPING_FILE") \
          > "$OUTPUT_FILE"
        
        # --- Summary & Verification ---
        echo "âœ… Release map generated: $OUTPUT_FILE"
        PACKAGE_COUNT=$(jq '.packages | keys | length' "$OUTPUT_FILE")
        echo "ðŸ“¦ Total packages mapped: $PACKAGE_COUNT"
        echo "ðŸ“„ Release map preview:"
        jq '._metadata' "$OUTPUT_FILE"
        echo
        jq '.packages | to_entries | .[0:2] | from_entries' "$OUTPUT_FILE"

        
    - name: Create additional metadata
      run: |
        echo "ðŸ“‹ Creating additional metadata files..."
        
        # Create releases.json with detailed information
        jq '[.[] | select(.assets != null) | {
          tag: .tag_name,
          name: .name,
          published_at: .published_at,
          prerelease: .prerelease,
          draft: .draft,
          packages: [.assets[] | select(.name | endswith(".deb")) | {
            name: .name,
            size: .size,
            download_count: .download_count,
            created_at: .created_at,
            browser_download_url: .browser_download_url
          }]
        }]' releases.json > public/releases.json
        
        # Create index.html for the repository
        cat > public/index.html << 'HTMLEOF'
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Noraneko APT Repository</title>
            <style>
                body { font-family: system-ui; max-width: 800px; margin: 40px auto; padding: 0 20px; }
                pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
                code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; }
                h1 { color: #333; }
                .section { margin: 30px 0; }
            </style>
        </head>
        <body>
            <h1>Noraneko APT Repository</h1>
            <div class="section">
                <h2>Setup Instructions</h2>
                <p>Add this repository to your system:</p>
                <pre><code>curl -fsSL https://apt.yourdomain.com/KEY.gpg | sudo gpg --dearmor -o /usr/share/keyrings/noraneko.gpg
        echo "deb [signed-by=/usr/share/keyrings/noraneko.gpg] https://apt.yourdomain.com alpha main" | sudo tee /etc/apt/sources.list.d/noraneko.list
        sudo apt update</code></pre>
            </div>
            <div class="section">
                <h2>Available Resources</h2>
                <ul>
                    <li><a href="/release-map.json">Release Map</a> - Package to release mapping (includes pool paths)</li>
                    <li><a href="/releases.json">Releases</a> - Detailed release information</li>
                    <li><a href="/KEY.gpg">GPG Key</a> - Repository signing key</li>
                </ul>
            </div>
            <div class="section">
                <h2>How it works</h2>
                <p>This repository uses Cloudflare Workers to proxy .deb files from GitHub releases. 
                When APT requests a package from the pool (e.g., <code>pool/main/n/noraneko-alpha/noraneko-alpha_0.2.0~build1_amd64.deb</code>),
                the worker maps it to the original GitHub release asset and serves it directly.</p>
            </div>
        </body>
        </html>
        HTMLEOF
        
        echo "âœ… Metadata files created"
        ls -lh public/
        
    - name: Deploy to Cloudflare Workers
      uses: cloudflare/wrangler-action@v3
      with:
        apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        
    - name: Commit changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "github-actions"
        git add public/ dists/ db/ pool/ 2>/dev/null || true
        git commit -m "Update APT repository [skip ci]" || echo "No changes to commit"
        git push || echo "Nothing to push"
